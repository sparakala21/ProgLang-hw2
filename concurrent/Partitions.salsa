module concurrent;
import java.io.*;
import java.util.*;

behavior Partitions{
  // vars
  Integer ActorNum;
  Map color_to_node = new HashMap();
  Map edge_to_node = new HashMap();
  Set internal_node = new HashSet();
  Set All_colors = new HashSet();
  Map influential = new HashMap();

  Partitions(Integer a, List NodeList, List ColorList, List EdgeList){
    this.ActorNum = a;

    for(int i = 0; i < NodeList.size(); i++) {
      String name = (String) NodeList.get(i);
      int n = Integer.parseInt(name);
      internal_node.add(n);

      String color = (String) ColorList.get(i);
      if(!color_to_node.containsKey(color))
      {
        All_colors.add(color);
        List l = new ArrayList();
        l.add(n);
        color_to_node.put(color, l);
      }
      else{
        List l = (List) color_to_node.get(color);
        l.add(n);
        color_to_node.put(color, l);
      }
    }
    for(int i=0;i<EdgeList.size();i++)
    {
      String[] pair =(String[]) EdgeList.get(i);
      String s = pair[0];
      String e = pair[1];
      int start = Integer.parseInt(s);
      int end = Integer.parseInt(e);
      if(!edge_to_node.containsKey(start))
      {
        List l = new ArrayList();
        l.add(end);
        edge_to_node.put(start,l);
      }
      else{
        List l = (List) edge_to_node.get(start);
        l.add(end);
        edge_to_node.put(start, l);
      }
      if(!edge_to_node.containsKey(end))
      {
        List l = new ArrayList();
        l.add(start);
        edge_to_node.put(end,l);
      }
      else{
        List l = (List) edge_to_node.get(end);
        l.add(start);
        edge_to_node.put(end, l);
      }
    }
    Iterator it = internal_node.iterator();
    while(it.hasNext()){
      int deg = 0;
      int n = (int) it.next();
      if(edge_to_node.containsKey(n)){
        List t = (List) edge_to_node.get(n);
        deg += t.size();
      }
      influential.put(n,deg);
    }

  }
  
  List computePartA(){
    List ret = new ArrayList();
    Iterator itr = All_colors.iterator();
    while(itr.hasNext()){
      List info = new ArrayList();
      int deg = 0;
      String c = (String) itr.next();

      List temp = (List) color_to_node.get(c);

      int count = temp.size();

      for(int k = 0; k < count; k++){
        
        int node = (int) temp.get(k);

        List t = (List) edge_to_node.get(node);
        int num = t.size();
        deg += num;
      }
      info.add(c);
      info.add(count);
      info.add(deg);
      standardOutput<-println(c + ", " + count + ", " + deg);
      ret.add(info);
      
    }
    standardOutput<-println(ActorNum);
    return ret;
  }

  List computePartA_better()
  {
    List ret = new ArrayList();
    Map color_to_count = new HashMap();
    Map color_to_degree = new HashMap();
    Iterator itr = All_colors.iterator();

    while(itr.hasNext())
    {
      int deg = 0;
      String c = (String) itr.next();

      List temp = (List) color_to_node.get(c);

      int count = temp.size();
      for(int k = 0; k < count; k++){
        
        int node = (int) temp.get(k);

        List t = (List) edge_to_node.get(node);
        int num = t.size();
        deg += num;
      }
      color_to_count.put(c, count);
      color_to_degree.put(c, deg);
      standardOutput<-println(c + ", " + count + ", " + deg);
    }
    
    ret.add(color_to_count);
    ret.add(color_to_degree);
    standardOutput<-println("success");
    return ret;
  }
  //Get the degree of each internal node of Ap.
  // • Find the list of external nodes connected to Ap. (Any node in the edge list that is not in the node list is an
  // external node of Ap)
  // • For each external node n, message all other actors requesting the degree of node n. (An actor should return
  // 0 if node n does not exist in their local partition).
  // • Find the largest degree node(s) from among the internal and external nodes of actor Ap. If there are multiple
  // nodes of the same max degree, return all such nodes
  void CalcMostInfluential(){
    // 1. Get the degree of each internal node of Ap
    // This has already been done during the initialization and stored in the 'influential' map
    
    // 2. Find the list of external nodes connected to Ap
    Set external_nodes = new HashSet();
    Iterator itr = edge_to_node.iterator();
    while(itr.hasNext()){
      List neighbors = (List) itr.next();
      for(int i = 0; i < neighbors.size(); i++){
        int node = (int) neighbors.get(i);
        if(!internal_node.contains(node)){
          external_nodes.add(node);
        }
      }
    }
  
    // 3. For each external node, message all other actors requesting the degree of node
    // This requires some form of inter-actor communication. Here, I'll just mock this step.
    // Ideally, this should be replaced by the real communication logic.
    Map external_degrees = new HashMap();
    for(Object node : external_nodes){
      int external_degree = mockMessageOtherActorsForDegree((int) node);
      external_degrees.put(node, external_degree);
    }
  
    // 4. Find the largest degree node(s) from among the internal and external nodes of actor Ap
    int max_degree = 0;
    List max_degree_nodes = new ArrayList();

    Set nodes = (Set) influential.keySet();

    Iterator itr = nodes.iterator();

    while(itr.hasNext())
    {
      int node = (int) itr.next();
      int degree =(int) influential.get(node);
      if(degree > max_degree){
        max_degree = degree;
        max_degree_nodes.clear();
        max_degree_nodes.add(node);
      }else if(degree == max_degree){
        max_degree_nodes.add(node);
      }
    }

    Iterator itr = external_degrees.iterator();
    while(itr.hasNext()){
      int degree = (int) itr.next();
      if(degree > max_degree){
        max_degree = degree;
        max_degree_nodes.clear();
        max_degree_nodes.add(key);
      }else if(degree == max_degree){
        max_degree_nodes.add(key);
      }
    }
  
    // 5. If there are multiple nodes of the same max degree, return all such nodes
    standardOutput<-println("Nodes with max degree (" + max_degree + "): " + max_degree_nodes);
  }
  
  
}
